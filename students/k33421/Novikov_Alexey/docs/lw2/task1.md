# Различия между threading, multiprocessing и async в Python

???+ question "Задание"

    Напишите три различных программы на Python, использующие каждый из подходов: threading, multiprocessing и async.  
    Каждая программа должна решать считать сумму всех чисел от 1 до 1000000.  
    Разделите вычисления на несколько параллельных задач для ускорения выполнения.

=== "sync"

    ```Python
    --8<-- "lr2/task1/sync_sum.py"
    ```
    
    Синхронный вариант используется для более наглядного сравнения.  
    Просто сумиируем все числа.

=== "threading"

    ```Python
    --8<-- "lr2/task1/threading_sum.py"
    ```

    Для удобства создаём свой класс на основе `#!py3 threding.Thread`, в который добавим 3 новых аттрибута: 
    `#!py3 start_value` (число, с которого начинать подсчёт), `#!py3 end_value` (число, на котором закончить подсчёт) и 
    `#!py3 result` (полученная потоком сумма).  

    Также переопределим метод `#!py3 run()`, в котором будем считать сумму для инициализированных чисел. Именно эта функция 
    будет запускаться при вызове метода `#!py3 start()`.

    Разделим 1000000 на 4 равных куска и инициализируем потоки на их основе.  
    В цикле запустим каждый поток и так же в цикле дождёмся их окончания.

=== "multiprocessing"

    ```Python
    --8<-- "lr2/task1/multiprocessing_sum.py"
    ```

    Для подсчёта суммы создадим функцию с двумя аргументами: началом и концом.

    Внутри основной функции с помощью контекстного менеджера создадим пул из 4 процессов.  

    Затем вызовем у этого пула метод `#!py3 starmap()`, где в качестве первого аргумента используем функцию сумму, 
    а в качестве второго список кортежей с аргументами функции.  

    Каждый элемент этого списка – аргументы для вызова функции каждым процессом.

    Результатом вызова метода `#!py3 starmap()` будет список результатов вызова функции суммы каждым процессом.
    

=== "asyncio"

    ```Python
    --8<-- "lr2/task1/asyncio_sum.py"
    ```

    Здесь история очень похожа на multiprocessing, но функция суммы и основная функции стали асинхронными, а 
    вместо пула и процессов создаём здесь список задач, каждая из которых вызовет нужную нам функцию с нужными аргументами.

    Обернём список задач в футуру и вызовем её с помощью `#!py3 await`: результатом так же станет список сумм.

### Сравнение

| Подход          | Время выполнения     |
|-----------------|----------------------|
| sync            | 0.010335206985473633 |
| threading       | 0.010432004928588867 |
| multiprocessing | 0.05666303634643555  |
| asyncio         | 0.008662939071655273 |


Поставленное задание по моему мнению максимально некорректно.

Вычисления – CPU-bound задача, но предлагаемое вычисление слишком тривиально: даже обычное синхронное вычисление происходит 
за сотую секунды.

В итоге получаем, что multiprocessing, который лучше всех из используемых подходов справляется с CPU-bound задачами, показал 
наихудший результат.